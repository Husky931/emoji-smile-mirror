import {
  FaceLandmarker,
  FilesetResolver,
} from "./vendor/tasks-vision/vision_bundle.js"; // Local paths only: const wasmRoot = "./vendor/tasks-vision/wasm"; // local WASM folder you copied const MODEL_TASK_URL = "./assets/face_landmarker.task"; // your local model const canvas = document.getElementById("canvas"); const ctx = canvas.getContext("2d"); const btnStart = document.getElementById("btnStart"); const btnCalibrate = document.getElementById("btnCalibrate"); const chkPrivacy = document.getElementById("chkPrivacy"); const btnFS = document.getElementById("btnFS"); let video = null; let running = false; let landmarker = null; let baseline = null; // blendshape baseline after calibration const EMOJI_SET = { neutral: "😐", smile: "🙂", surprise:"😮", frown: "😡", cheeky: "😜", }; // Map blendshape array -> {name: score} function blendMap(blendshapes) { const out = {}; for (const cat of blendshapes?.categories ?? []) out[cat.categoryName] = cat.score; return out; } function calibrate(blend) { if (!blend) return; baseline = { ...blend }; flash("Calibrated! Try smiling or opening your mouth."); } function pickEmoji(blend) { if (!blend) return EMOJI_SET.neutral; const b = baseline || {}; const get = (k) => (blend[k] ?? 0) - (b[k] ?? 0); const smile = Math.max(get("mouthSmileLeft"), get("mouthSmileRight")); const jawOpen = get("jawOpen"); const pucker = get("mouthPucker"); const frown = Math.max(get("mouthFrownLeft"), get("mouthFrownRight")); const cheek = Math.max(get("cheekPuffLeft"), get("cheekPuffRight")); const scores = { smile, surprise: jawOpen * 0.9 + pucker * 0.4, frown, cheeky: cheek + (get("tongueOut") ?? 0), }; const TH = { smile: 0.25, surprise: 0.28, frown: 0.20, cheeky: 0.22 }; let best = "neutral", bestScore = 0.15; for (const k of Object.keys(scores)) { const s = scores[k]; if (s > TH[k] && s > bestScore) { best = k; bestScore = s; } } return EMOJI_SET[best]; } function drawPrivacyOverlay() { const grd = ctx.createLinearGradient(0,0,canvas.width,canvas.height); grd.addColorStop(0,"rgba(18,22,32,0.95)"); grd.addColorStop(1,"rgba(28,34,48,0.95)"); ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width,canvas.height); } function drawEmoji(emoji) { const size = Math.min(canvas.width, canvas.height) * 0.3; ctx.font = ${Math.floor(size)}px system-ui, Apple Color Emoji, Segoe UI Emoji; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(emoji, canvas.width/2, canvas.height/2 + size*0.05); } function flash(text) { ctx.save(); ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0, canvas.height - 56, canvas.width, 56); ctx.fillStyle = "#fff"; ctx.font = "20px system-ui, sans-serif"; ctx.textAlign = "center"; ctx.fillText(text, canvas.width/2, canvas.height - 28); ctx.restore(); } async function setupModel() { // Load the local WASM runtime and create the face landmarker with the local model const fileset = await FilesetResolver.forVisionTasks(wasmRoot); landmarker = await FaceLandmarker.createFromOptions(fileset, { baseOptions: { modelAssetPath: MODEL_TASK_URL }, runningMode: "VIDEO", outputFaceBlendshapes: true, numFaces: 1, }); } async function setupCamera() { const v = document.createElement("video"); v.autoplay = true; v.playsInline = true; v.muted = true; const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 960, height: 540 }, audio: false }); v.srcObject = stream; await v.play(); video = v; // Match canvas to video aspect so the drawImage isn't distorted const vw = v.videoWidth || 960, vh = v.videoHeight || 540; const ratio = vw / vh; canvas.height = Math.round(canvas.width / ratio); } const nowMs = () => performance.now(); function loop() { if (!running) return; const ts = nowMs(); if (video && landmarker) { ctx.drawImage(video, 0, 0, canvas.width, canvas.height); const result = landmarker.detectForVideo(video, ts); const blendObj = blendMap(result?.faceBlendshapes?.[0]); if (chkPrivacy.checked) drawPrivacyOverlay(); drawEmoji(pickEmoji(blendObj)); } requestAnimationFrame(loop); } // UI btnStart.onclick = async () => { btnStart.disabled = true; try { await setupModel(); await setupCamera(); running = true; btnCalibrate.disabled = false; loop(); } catch (e) { console.error(e); alert("Camera/model failed to start. Use Chrome desktop and allow camera permission."); btnStart.disabled = false; } }; btnCalibrate.onclick = () => { if (!landmarker || !video) return; const res = landmarker.detectForVideo(video, nowMs()); const blendObj = blendMap(res?.faceBlendshapes?.[0]); calibrate(blendObj); }; btnFS.onclick = () => { if (!document.fullscreenElement) canvas.requestFullscreen().catch(()=>{}); else document.exitFullscreen(); };
